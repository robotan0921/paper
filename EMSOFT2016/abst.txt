contri 1 : mruby on TECSでのソフトウェア開発の作業効率を向上させる
contri 2 : 効率的に複数のmrubyプログラムを並行/並列動作させる

conclusion 1 : バイトコードローダによって作業効率が向上する
conclusion 2 : 使いずらかったマルチタスク処理が実用的になった
（conclusion 3 : コンポーネントとして実装したので，機能のつけ外しが簡単になっている）

アピールポイント
    BLuetooth Loaderによる効率的な開発が可能になる
        -OSの再起動が必要ない，SDカードの抜き差しも一度だけ
        - ×プラットフォームの起動時間
          ○転送するバイトコードのサイズ，ロード処理時間
                VMの数が増えるほど，差が大きくなる

          SDカードーー｜まとめてーーアプリだけ
          ×  コンパイル時間
          連続ロード　
            抜き差し      OSの再起動，ペアリング
        
        デザイン
            1：SDカード　←毎回抜き差し
            2：Bluetoothローダ　←まとめて送ると無駄がある
               //結論： [制約]Bluetoothデバイスだけ
               //         -ローダ自体は有線のシリアル接続でも使える
            3：AppとLibを分ける
                //LibはVMごとに共通に使える　←　共通と独自のLibを切り替えられる
                //頻繁に修正されるのはAppの方だから分けた，転送速度が速い

    既存のフレームワークより使いやすいマルチタスク処理
        コルーチンより使いやすい，速い
        オーバヘッドが少ない
          △  シングル,コルーチン,マルチのアプリケーションの実行時間の比較
          △  周期時間によるオーバヘッドの比較
        イベントフラグを使ったアプリケーションの同期
          ×  周期時間×（VMの数-1）以内

        デザイン
            -delayを使ったマルチタスク
                //異なる優先度のタスクを動かす場合に使えるが。。。
            -コルーチンを使ったマルチタスク
                //ノンプリエンプティブ
                //ユーザが自分でタスクを切り替える必要がある
                //コルーチンはマルチコアの恩恵を受けられない
            -RiteVMスケジューラを使ったマルチタスク
                //[制約]タスクを”平等に”動かしたいときだけ.
                //スケジューラがタスクを切り替える
                //ユーザはOSの機能を使わなくても並行動作できる
                //（プログラムの使いまわしができる）

    コンポーネントの利点を生かした設計
        周期ハンドラなどの機能の取り外し、再利用が容易
          ×  //カーネル設定ファイルCFGを書かなければならない.
        イベントフラグでは，VMの数にかかわらずCファイルの使いまわしができる
          ×  （コード変更行数）
        デザイン
            //結論：コンポーネントベース開発によって，RiteVMスケジューラの取り外しが簡単にできるため，
            //        優先度スケジューリングかフェアスケジューリングかを簡単に選択できる    
TODO:
    プラットフォーム起動時間測定
    コンパイル時間
    アプリケーションの同期の評価
    コード変更行数
    Loaderのapp_buf部分（内部変数として持たせる）
    共通と独自のLibを切り替えられる設計

    The loader, The RiteVM sceduler


